// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/21       [336405]
Creator        : jandrea
Date           : Fri Nov  7 15:37:10 2014
Host           : Linux sbgat230 3.13.0-36-generic #63-Ubuntu SMP Wed Sep 3 21:30:07 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/jandrea/WORK/SingleTop_tZ_Macro/TMVA
Training events: 52722
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
SeparationType: "giniindex" [Separation criterion for node splitting]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
nEventsMin: "100" [deprecated: Use MinNodeSize (in % of training events) instead]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "0.1896743.2" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 7
tree_topMass                  tree_topMass                  tree_topMass                  tree_topMass                                                    'F'    [59.7827987671,2670.22143555]
tree_asym                     tree_asym                     tree_asym                     tree_asym                                                       'F'    [-2.49411892891,2.49931979179]
tree_NBJets                   tree_NBJets                   tree_NBJets                   tree_NBJets                                                     'F'    [0,2]
tree_btagDiscri               tree_btagDiscri               tree_btagDiscri               tree_btagDiscri                                                 'F'    [-10,1]
tree_totPt                    tree_totPt                    tree_totPt                    tree_totPt                                                      'F'    [0.141447931528,808.431396484]
tree_leptWPt                  tree_leptWPt                  tree_leptWPt                  tree_leptWPt                                                    'F'    [20.0027351379,667.185180664]
tree_leadJetPt                tree_leadJetPt                tree_leadJetPt                tree_leadJetPt                                                  'F'    [30.0008945465,998.696105957]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 7 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "tree_topMass", "tree_asym", "tree_NBJets", "tree_btagDiscri", "tree_totPt", "tree_leptWPt", "tree_leadJetPt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[7];
   double fVmax[7];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[7];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.617398698039716);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.850348, 0, 1, 0.882859,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.845792,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371788,-99) , 
3, 0.95015, 0, 0, 0.506644,-99) , 
4, 38.6314, 0, 0, 0.786455,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269099,-99) , 
5, 116.018, 1, 0, 0.555445,-99) , 
NN(
0, 
0, 
-1, 33.7061, 0, -1, 0.214086,-99) , 
4, 58.7347, 0, 0, 0.309455,-99) , 
3, 0.47619, 0, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.424638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 256.036, 1, 1, 0.839019,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417874,-99) , 
4, 54.7396, 0, 0, 0.539433,-99) , 
3, 0.850348, 0, 0, 0.739493,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.78578,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419162,-99) , 
2, 1.04762, 0, 0, 0.440533,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.762847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224605,-99) , 
2, 1.04762, 0, 0, 0.232844,-99) , 
4, 29.5449, 0, 0, 0.36561,-99) , 
3, 0.47619, 0, 0, 0.508673,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.304036);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 230.001, 1, 1, 0.824153,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42343,-99) , 
4, 29.5322, 0, 0, 0.579065,-99) , 
3, 0.928001, 0, 0, 0.65453,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.540913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.420337,-99) , 
1, -0.12342, 0, 0, 0.497429,-99) , 
NN(
0, 
0, 
-1, 312.174, 0, -1, 0.298275,-99) , 
4, 29.5449, 0, 0, 0.421838,-99) , 
2, 0.0952381, 0, 0, 0.545341,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.232628);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.950116, 0, 1, 0.71143,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.695996,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.310319,-99) , 
2, 1.04762, 0, 0, 0.374749,-99) , 
0, 255.303, 1, 0, 0.647406,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513906,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.371017,-99) , 
1, 1.53607, 1, 0, 0.497021,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518453,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338171,-99) , 
0, 312.174, 0, 0, 0.381367,-99) , 
4, 29.5449, 0, 0, 0.458396,-99) , 
3, 0.47619, 0, 0, 0.527203,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.20809);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 230.001, 1, 1, 0.792187,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57042,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37507,-99) , 
0, 255.303, 1, 0, 0.529236,-99) , 
3, 0.950116, 0, 0, 0.613294,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600879,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446191,-99) , 
0, 432.703, 0, 0, 0.460537,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.339898,-99) , 
0, 166.831, 1, 0, 0.357547,-99) , 
5, 81.6392, 1, 0, 0.438146,-99) , 
3, 0.47619, 0, 0, 0.500493,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.144141);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.727138,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476682,-99) , 
0, 213.722, 1, 0, 0.676689,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.775969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400335,-99) , 
2, 1.04762, 0, 0, 0.441533,-99) , 
0, 261.849, 1, 0, 0.609328,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.685892,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485316,-99) , 
2, 1.04762, 0, 0, 0.497194,-99) , 
NN(
0, 
0, 
-1, 466.089, 0, -1, 0.313214,-99) , 
5, 112.457, 1, 0, 0.48173,-99) , 
4, 77.1214, 0, 0, 0.514654,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.195342);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.809524, 0, 1, 0.620454,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578787,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417183,-99) , 
6, 43.1793, 0, 0, 0.521315,-99) , 
6, 76.1292, 0, 0, 0.563315,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.670646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448479,-99) , 
0, 549.707, 0, 0, 0.466309,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641393,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.299557,-99) , 
0, 182.913, 1, 0, 0.325263,-99) , 
5, 137.413, 1, 0, 0.432716,-99) , 
5, 81.6392, 1, 0, 0.53695,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.121183);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 230.001, 1, 1, 0.766564,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568616,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464324,-99) , 
1, -0.116227, 0, 0, 0.531386,-99) , 
3, 0.964001, 0, 0, 0.569993,-99) , 
NN(
0, 
0, 
-1, -1.54299, 0, -1, 0.472577,-99) , 
2, 0.0952381, 0, 0, 0.522725,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.137493);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.812662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.338855,-99) , 
5, 137.337, 1, 0, 0.77149,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442394,-99) , 
1, -0.0431477, 0, 0, 0.535375,-99) , 
3, 0.809524, 0, 0, 0.632412,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5472,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411252,-99) , 
5, 124.848, 1, 0, 0.539393,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.785069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429637,-99) , 
2, 1.04762, 0, 0, 0.439499,-99) , 
4, 22.1355, 0, 0, 0.518177,-99) , 
4, 115.611, 0, 0, 0.531355,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.107712);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.791197,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49849,-99) , 
6, 50.8049, 0, 0, 0.691282,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.884761,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413476,-99) , 
2, 1.04762, 0, 0, 0.447446,-99) , 
0, 261.849, 1, 0, 0.617858,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447686,-99) , 
1, 1.152, 1, 0, 0.509405,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628696,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.369752,-99) , 
0, 576.078, 0, 0, 0.385033,-99) , 
1, -1.54299, 0, 0, 0.501144,-99) , 
4, 115.611, 0, 0, 0.514421,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.0658682);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 211.687, 1, 1, 0.753238,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.625295,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486241,-99) , 
3, 0.206192, 1, 0, 0.532582,-99) , 
3, 0.809524, 0, 0, 0.620999,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.770389,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490591,-99) , 
0, 635.123, 0, 0, 0.495256,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.318502,-99) , 
0, 731.683, 0, 0, 0.36168,-99) , 
6, 214.514, 1, 0, 0.488707,-99) , 
4, 115.611, 0, 0, 0.503572,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.10105);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 50.8049, 0, 1, 0.685572,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.876547,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435036,-99) , 
2, 1.04762, 0, 0, 0.466117,-99) , 
0, 261.849, 1, 0, 0.618725,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525415,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.427637,-99) , 
6, 38.7848, 0, 0, 0.511178,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506418,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.332967,-99) , 
0, 731.683, 0, 0, 0.369918,-99) , 
6, 214.514, 1, 0, 0.504311,-99) , 
4, 115.611, 0, 0, 0.517083,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.116573);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 211.687, 1, 1, 0.731181,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.607185,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486107,-99) , 
2, 0.0952381, 1, 0, 0.530753,-99) , 
3, 0.809524, 0, 0, 0.609498,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423108,-99) , 
0, 133.552, 0, 0, 0.519633,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508272,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.429122,-99) , 
5, 50.8209, 1, 0, 0.463294,-99) , 
0, 186.77, 1, 0, 0.487949,-99) , 
4, 115.611, 0, 0, 0.501373,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.076239);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 50.8049, 0, 1, 0.660848,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.871279,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448692,-99) , 
2, 1.04762, 0, 0, 0.477889,-99) , 
0, 261.849, 1, 0, 0.604157,-99) , 
NN(
NN(
0, 
0, 
-1, 34.7537, 1, 1, 0.584916,-99) , 
NN(
0, 
0, 
-1, 260.643, 1, -1, 0.477436,-99) , 
2, 1.04762, 0, 0, 0.483809,-99) , 
4, 115.611, 0, 0, 0.497003,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.0562627);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.809524, 0, 1, 0.597087,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510579,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356032,-99) , 
1, 2.11437, 1, 0, 0.506536,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.641495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403111,-99) , 
4, 88.2886, 0, 0, 0.416289,-99) , 
1, -1.54299, 0, 0, 0.500602,-99) , 
4, 115.611, 0, 0, 0.511102,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0535034);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 36.7738, 1, 1, 0.687735,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48886,-99) , 
1, 0.647313, 0, 0, 0.518932,-99) , 
3, 0.809524, 0, 0, 0.58348,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.762155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48681,-99) , 
0, 735.468, 0, 0, 0.49088,-99) , 
NN(
0, 
0, 
-1, 112.559, 1, -1, 0.247739,-99) , 
6, 352.899, 1, 0, 0.488962,-99) , 
4, 115.611, 0, 0, 0.499208,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0479297);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 36.7738, 1, 1, 0.676131,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542832,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446643,-99) , 
3, 0.550819, 1, 0, 0.523138,-99) , 
3, 0.809524, 0, 0, 0.581341,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.628221,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496404,-99) , 
0, 444.281, 0, 0, 0.505533,-99) , 
NN(
0, 
0, 
-1, 366.167, 1, -1, 0.367229,-99) , 
6, 260.643, 1, 0, 0.501944,-99) , 
4, 115.611, 0, 0, 0.510521,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0698073);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 62.2562, 0, 1, 0.546478,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51368,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.400744,-99) , 
1, 1.78571, 1, 0, 0.503853,-99) , 
0, 184.089, 1, 0, 0.52209,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.618487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.332973,-99) , 
0, 491.256, 0, 0, 0.397024,-99) , 
NN(
0, 
0, 
-1, 221.229, 1, -1, 0.26602,-99) , 
6, 210.072, 1, 0, 0.347385,-99) , 
5, 174.094, 1, 0, 0.518821,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0850895);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.904762, 0, 1, 0.601497,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416479,-99) , 
0, 130.814, 0, 0, 0.488162,-99) , 
6, 62.2562, 0, 0, 0.529282,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.590847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48037,-99) , 
0, 539.251, 0, 0, 0.489429,-99) , 
NN(
0, 
0, 
-1, 0.428567, 1, -1, 0.341689,-99) , 
5, 174.094, 1, 0, 0.485033,-99) , 
0, 184.089, 1, 0, 0.503651,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.084839);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.746482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.36418,-99) , 
4, 32.325, 0, 0, 0.659862,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410346,-99) , 
6, 251.859, 1, 0, 0.511007,-99) , 
3, 0.904762, 0, 0, 0.532162,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492337,-99) , 
3, 0.904762, 0, 0, 0.519032,-99) , 
NN(
0, 
0, 
-1, 50.9158, 1, -1, 0.465726,-99) , 
6, 51.965, 0, 0, 0.489137,-99) , 
6, 76.1292, 0, 0, 0.508421,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0566479);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.96991, 1, 1, 0.703636,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490545,-99) , 
2, 0.0952381, 0, 0, 0.512614,-99) , 
0, 633.113, 0, 0, 0.515558,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527392,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.398984,-99) , 
1, 0.784447, 1, 0, 0.465422,-99) , 
NN(
0, 
0, 
-1, 60.6914, 1, -1, 0.335941,-99) , 
1, -0.245024, 0, 0, 0.427828,-99) , 
6, 214.514, 1, 0, 0.510702,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0503693);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.96991, 1, 1, 0.691688,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426114,-99) , 
5, 122.617, 1, 0, 0.512138,-99) , 
0, 633.113, 0, 0, 0.514878,-99) , 
NN(
0, 
0, 
-1, -0.245024, 0, -1, 0.43123,-99) , 
6, 214.514, 1, 0, 0.510265,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.049347);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 344.708, 0, 1, 0.517665,-99) , 
NN(
0, 
0, 
-1, 371.357, 1, -1, 0.418391,-99) , 
1, 1.95584, 1, 0, 0.511636,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.799905,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476261,-99) , 
0, 732.288, 0, 0, 0.47929,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501682,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.292705,-99) , 
1, -0.630293, 0, 0, 0.342799,-99) , 
6, 222.232, 1, 0, 0.473363,-99) , 
1, -0.354074, 0, 0, 0.50031,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0491479);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.704076,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440106,-99) , 
6, 55.3054, 0, 0, 0.613081,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555319,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.37927,-99) , 
0, 245.007, 1, 0, 0.475937,-99) , 
5, 55.8262, 1, 0, 0.54302,-99) , 
NN(
NN(
0, 
0, 
-1, 187.594, 1, 1, 0.664641,-99) , 
NN(
0, 
0, 
-1, 352.899, 1, -1, 0.488495,-99) , 
4, 110.112, 0, 0, 0.490621,-99) , 
4, 115.611, 0, 0, 0.496185,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0432933);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.765369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463785,-99) , 
6, 308.491, 1, 0, 0.661963,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523972,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488404,-99) , 
0, 201.685, 1, 0, 0.507063,-99) , 
0, 805.622, 0, 0, 0.508806,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500486,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.332917,-99) , 
5, 221.229, 1, 0, 0.441791,-99) , 
NN(
0, 
0, 
-1, 0.266799, 0, -1, 0.30354,-99) , 
3, 0.428569, 1, 0, 0.389735,-99) , 
5, 174.094, 1, 0, 0.506644,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0543124);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.59651,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.285857,-99) , 
1, 1.9994, 1, 0, 0.56919,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516063,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479489,-99) , 
6, 54.661, 0, 0, 0.502491,-99) , 
0, 432.703, 0, 0, 0.508249,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378958,-99) , 
5, 197.757, 1, 0, 0.438394,-99) , 
NN(
0, 
0, 
-1, 0.266799, 0, -1, 0.312769,-99) , 
3, 0.428569, 1, 0, 0.391269,-99) , 
5, 174.094, 1, 0, 0.506133,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0908272);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 65.9537, 0, 1, 0.603471,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.74293,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.436183,-99) , 
0, 230.001, 1, 0, 0.665082,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470738,-99) , 
0, 308.396, 0, 0, 0.482325,-99) , 
3, 0.952392, 0, 0, 0.499504,-99) , 
3, -0.571429, 1, 0, 0.502167,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0506001);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 769.659, 0, 1, 0.666044,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518343,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44247,-99) , 
5, 122.617, 1, 0, 0.514322,-99) , 
0, 633.113, 0, 0, 0.516574,-99) , 
NN(
0, 
0, 
-1, 475.947, 1, -1, 0.428474,-99) , 
6, 214.514, 1, 0, 0.511717,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0280112);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 769.659, 0, 1, 0.654696,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506378,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42126,-99) , 
1, -1.78077, 0, 0, 0.503018,-99) , 
0, 633.113, 0, 0, 0.505253,-99) , 
NN(
0, 
0, 
-1, 475.947, 1, -1, 0.440907,-99) , 
6, 214.514, 1, 0, 0.501714,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0389601);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.714963,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.421993,-99) , 
6, 354.505, 1, 0, 0.636006,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511468,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479664,-99) , 
0, 201.685, 1, 0, 0.496317,-99) , 
0, 805.622, 0, 0, 0.497841,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.584922,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.388625,-99) , 
0, 677.324, 0, 0, 0.424434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.289948,-99) , 
5, 244.7, 1, 0, 0.394992,-99) , 
5, 174.094, 1, 0, 0.495995,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0166661);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.72945,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424254,-99) , 
3, 0.333304, 1, 0, 0.659153,-99) , 
NN(
0, 
0, 
-1, 187.96, 1, -1, 0.494513,-99) , 
0, 805.622, 0, 0, 0.496362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.256197,-99) , 
6, 445.156, 1, 0, 0.495622,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0177843);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.726148,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.42833,-99) , 
3, 0.333304, 1, 0, 0.657415,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502574,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446108,-99) , 
6, 187.96, 1, 0, 0.498679,-99) , 
0, 805.622, 0, 0, 0.500456,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.259386,-99) , 
6, 445.156, 1, 0, 0.499717,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0294493);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.722597,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.43269,-99) , 
3, 0.333304, 1, 0, 0.655549,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533409,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490379,-99) , 
4, 115.611, 0, 0, 0.494846,-99) , 
0, 805.622, 0, 0, 0.496639,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.262817,-99) , 
6, 445.156, 1, 0, 0.495925,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0383111);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.769749,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498738,-99) , 
3, 0.904762, 0, 0, 0.535981,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553406,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489713,-99) , 
0, 437.044, 0, 0, 0.495679,-99) , 
5, 30.2723, 1, 0, 0.502523,-99) , 
NN(
0, 
0, 
-1, 676.571, 1, -1, 0.310514,-99) , 
5, 235.73, 1, 0, 0.501655,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0340175);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.70178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482791,-99) , 
4, 100.354, 1, 0, 0.655703,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512226,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456237,-99) , 
6, 187.93, 1, 0, 0.508511,-99) , 
0, 767.016, 0, 0, 0.510315,-99) , 
NN(
0, 
0, 
-1, 63.0914, 0, -1, 0.323432,-99) , 
6, 399.028, 1, 0, 0.509311,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0281469);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.416875,-99) , 
1, 2.0917, 1, 0, 0.506215,-99) , 
NN(
0, 
0, 
-1, 283.042, 1, -1, 0.44404,-99) , 
1, -1.78077, 0, 0, 0.503764,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.3765,-99) , 
1, 0.341692, 0, 0, 0.433209,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.312428,-99) , 
5, 244.7, 1, 0, 0.407186,-99) , 
5, 174.094, 1, 0, 0.502052,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0147394);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.706253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431641,-99) , 
3, 0.333304, 1, 0, 0.642251,-99) , 
NN(
0, 
0, 
-1, 130.734, 0, -1, 0.49517,-99) , 
0, 805.622, 0, 0, 0.496781,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.266822,-99) , 
6, 445.156, 1, 0, 0.496085,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0175933);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.703186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.435261,-99) , 
3, 0.333304, 1, 0, 0.640645,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502874,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46202,-99) , 
0, 130.734, 0, 0, 0.498855,-99) , 
0, 805.622, 0, 0, 0.500404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269715,-99) , 
6, 445.156, 1, 0, 0.499708,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0140954);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707711,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459249,-99) , 
5, 149.214, 1, 0, 0.638717,-99) , 
NN(
0, 
0, 
-1, 177.271, 1, -1, 0.495321,-99) , 
0, 805.622, 0, 0, 0.496883,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.273195,-99) , 
6, 445.156, 1, 0, 0.496212,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.00852728);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.688305,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487832,-99) , 
4, 100.354, 1, 0, 0.645912,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500194,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394779,-99) , 
5, 177.271, 1, 0, 0.4988,-99) , 
0, 767.016, 0, 0, 0.500577,-99) , 
NN(
0, 
0, 
-1, 63.0914, 0, -1, 0.331748,-99) , 
6, 399.028, 1, 0, 0.49968,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0112632);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.696953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438754,-99) , 
3, 0.333304, 1, 0, 0.636671,-99) , 
NN(
0, 
0, 
-1, 177.271, 1, -1, 0.496777,-99) , 
0, 805.622, 0, 0, 0.498296,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27771,-99) , 
6, 445.156, 1, 0, 0.497637,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0090675);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.702452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461326,-99) , 
5, 149.214, 1, 0, 0.635422,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500915,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404209,-99) , 
5, 177.271, 1, 0, 0.499593,-99) , 
0, 805.622, 0, 0, 0.501065,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.279974,-99) , 
6, 445.156, 1, 0, 0.500406,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0105149);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.684622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489324,-99) , 
4, 100.354, 1, 0, 0.643306,-99) , 
NN(
0, 
0, 
-1, 177.271, 1, -1, 0.497333,-99) , 
0, 767.016, 0, 0, 0.49909,-99) , 
NN(
0, 
0, 
-1, 63.0914, 0, -1, 0.335931,-99) , 
6, 399.028, 1, 0, 0.498227,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0100671);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.682347,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491952,-99) , 
4, 100.354, 1, 0, 0.642011,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.404224,-99) , 
5, 177.271, 1, 0, 0.499962,-99) , 
0, 767.016, 0, 0, 0.501669,-99) , 
NN(
0, 
0, 
-1, 63.0914, 0, -1, 0.338281,-99) , 
6, 399.028, 1, 0, 0.500807,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0306965);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.842614,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.323124,-99) , 
4, 166.17, 1, 0, 0.674377,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.762495,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438032,-99) , 
4, 34.9984, 1, 0, 0.511041,-99) , 
4, 87.9576, 0, 0, 0.544748,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494769,-99) , 
0, 805.622, 0, 0, 0.496172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.271224,-99) , 
6, 445.156, 1, 0, 0.495478,-99) , 
2, 1.04762, 0, 0, 0.498394,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.014652);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676251,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490814,-99) , 
4, 100.354, 1, 0, 0.636913,-99) , 
NN(
0, 
0, 
-1, -0.571429, 1, 1, 0.504903,-99) , 
0, 767.016, 0, 0, 0.506483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.224935,-99) , 
4, 63.0914, 0, 0, 0.344161,-99) , 
6, 399.028, 1, 0, 0.505631,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.00920508);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.673035,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494476,-99) , 
4, 100.354, 1, 0, 0.635083,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.567286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499512,-99) , 
3, -0.571429, 1, 0, 0.50124,-99) , 
0, 767.016, 0, 0, 0.502839,-99) , 
NN(
0, 
0, 
-1, 63.0914, 0, -1, 0.34432,-99) , 
6, 399.028, 1, 0, 0.502009,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0160793);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671006,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496778,-99) , 
4, 100.354, 1, 0, 0.633929,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504634,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.412508,-99) , 
5, 177.271, 1, 0, 0.503424,-99) , 
0, 767.016, 0, 0, 0.504981,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501439,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.229122,-99) , 
4, 63.0914, 0, 0, 0.346401,-99) , 
6, 399.028, 1, 0, 0.504152,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0144854);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.687902,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451603,-99) , 
5, 149.214, 1, 0, 0.621845,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539988,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497058,-99) , 
2, 1.04762, 0, 0, 0.499578,-99) , 
0, 805.622, 0, 0, 0.500887,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.293119,-99) , 
6, 445.156, 1, 0, 0.50028,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0191018);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.677788,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432678,-99) , 
3, 0.333304, 1, 0, 0.620508,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466001,-99) , 
6, 187.96, 1, 0, 0.502774,-99) , 
0, 805.622, 0, 0, 0.504033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.29613,-99) , 
6, 445.156, 1, 0, 0.503427,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.00911543);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.682178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453808,-99) , 
5, 149.214, 1, 0, 0.618308,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498081,-99) , 
4, 308.061, 0, 0, 0.498653,-99) , 
0, 805.622, 0, 0, 0.499929,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.300127,-99) , 
6, 445.156, 1, 0, 0.499349,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0133724);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.680198,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456068,-99) , 
5, 149.214, 1, 0, 0.617458,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451411,-99) , 
1, -1.78077, 0, 0, 0.500917,-99) , 
0, 805.622, 0, 0, 0.502158,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.302045,-99) , 
6, 445.156, 1, 0, 0.501578,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.00905016);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.665345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497075,-99) , 
1, 1.75203, 1, 0, 0.627782,-99) , 
NN(
0, 
0, 
-1, 2.02375, 1, -1, 0.497742,-99) , 
0, 767.016, 0, 0, 0.49928,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506679,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.236028,-99) , 
4, 63.0914, 0, 0, 0.353814,-99) , 
6, 399.028, 1, 0, 0.498529,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0116153);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663327,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499337,-99) , 
1, 1.75203, 1, 0, 0.626677,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44484,-99) , 
1, 2.02375, 1, 0, 0.500004,-99) , 
0, 767.016, 0, 0, 0.501501,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504417,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.237664,-99) , 
4, 63.0914, 0, 0, 0.353906,-99) , 
6, 399.028, 1, 0, 0.50074,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0650638);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 114.775, 1, 1, 0.669963,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.600856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484543,-99) , 
5, 35.7532, 1, 0, 0.518151,-99) , 
6, 65.9537, 0, 0, 0.562658,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.711029,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453164,-99) , 
4, 38.8099, 0, 0, 0.638819,-99) , 
NN(
0, 
0, 
-1, 0.453636, 1, -1, 0.482102,-99) , 
3, 0.952392, 0, 0, 0.49637,-99) , 
3, -0.571429, 1, 0, 0.498054,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.033638);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.682913,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44972,-99) , 
3, 0.333304, 1, 0, 0.628902,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514428,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481035,-99) , 
0, 130.734, 0, 0, 0.511147,-99) , 
0, 805.622, 0, 0, 0.512405,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.318192,-99) , 
6, 445.156, 1, 0, 0.511851,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0306549);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.904762, 0, 1, 0.538776,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548172,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.494083,-99) , 
0, 437.044, 0, 0, 0.499105,-99) , 
5, 30.2723, 1, 0, 0.50583,-99) , 
NN(
0, 
0, 
-1, 676.571, 1, -1, 0.352312,-99) , 
5, 235.73, 1, 0, 0.505165,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0210197);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 767.016, 0, 1, 0.509803,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515624,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.247438,-99) , 
4, 63.0914, 0, 0, 0.365745,-99) , 
6, 399.028, 1, 0, 0.509069,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0105217);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.660521,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498876,-99) , 
1, 1.75203, 1, 0, 0.624207,-99) , 
NN(
0, 
0, 
-1, 308.061, 0, 1, 0.503124,-99) , 
0, 767.016, 0, 0, 0.504549,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510373,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.251373,-99) , 
4, 63.0914, 0, 0, 0.365947,-99) , 
6, 399.028, 1, 0, 0.503845,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0275507);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 115.814, 0, 1, 0.509778,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452277,-99) , 
3, 0.47619, 1, 0, 0.488456,-99) , 
5, 61.081, 1, 0, 0.501887,-99) , 
NN(
0, 
0, 
-1, 676.571, 1, -1, 0.353108,-99) , 
5, 235.73, 1, 0, 0.501243,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0413739);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585342,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492533,-99) , 
3, 0.904762, 0, 0, 0.50696,-99) , 
NN(
0, 
0, 
-1, -0.122051, 1, -1, 0.481623,-99) , 
1, -0.003356, 0, 0, 0.49703,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.651867,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391297,-99) , 
2, 0.0952381, 0, 0, 0.489159,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.234739,-99) , 
1, 2.38613, 1, 0, 0.398883,-99) , 
1, 2.26154, 1, 0, 0.496039,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0265418);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.904762, 0, 1, 0.514098,-99) , 
NN(
0, 
0, 
-1, -0.122051, 1, -1, 0.491959,-99) , 
1, -0.003356, 0, 0, 0.505421,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.64242,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401194,-99) , 
2, 0.0952381, 0, 0, 0.49169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.242253,-99) , 
1, 2.38613, 1, 0, 0.403516,-99) , 
1, 2.26154, 1, 0, 0.504398,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0299756);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.585028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464483,-99) , 
4, 59.877, 1, 0, 0.538761,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504498,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.410278,-99) , 
5, 138.194, 1, 0, 0.501688,-99) , 
0, 432.703, 0, 0, 0.504989,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.356928,-99) , 
4, 19.9103, 0, 0, 0.493179,-99) , 
NN(
0, 
0, 
-1, 61.129, 0, -1, 0.306204,-99) , 
0, 374.617, 1, 0, 0.446425,-99) , 
1, 2.02375, 1, 0, 0.503014,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0400304);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577733,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471947,-99) , 
4, 59.877, 1, 0, 0.537093,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.506278,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475339,-99) , 
5, 59.3999, 1, 0, 0.49464,-99) , 
0, 432.703, 0, 0, 0.498414,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556551,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414009,-99) , 
0, 211.945, 1, 0, 0.489073,-99) , 
NN(
0, 
0, 
-1, 61.129, 0, -1, 0.312609,-99) , 
0, 374.617, 1, 0, 0.445082,-99) , 
1, 2.02375, 1, 0, 0.49662,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0188173);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.676503,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.462725,-99) , 
5, 149.214, 1, 0, 0.616266,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.663637,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492948,-99) , 
4, 308.061, 0, 0, 0.493501,-99) , 
0, 805.622, 0, 0, 0.494795,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.322607,-99) , 
6, 445.156, 1, 0, 0.494304,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0103459);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 224.327, 1, 1, 0.624874,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666253,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49755,-99) , 
4, 308.061, 0, 0, 0.498083,-99) , 
0, 767.016, 0, 0, 0.499568,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530391,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.244973,-99) , 
4, 63.0914, 0, 0, 0.370209,-99) , 
6, 399.028, 1, 0, 0.498907,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0206245);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 224.327, 1, 1, 0.622445,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505718,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482958,-99) , 
1, 1.07262, 1, 0, 0.500653,-99) , 
0, 767.016, 0, 0, 0.502078,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527814,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.246892,-99) , 
4, 63.0914, 0, 0, 0.370315,-99) , 
6, 399.028, 1, 0, 0.501406,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.00987524);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.666308,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461524,-99) , 
5, 149.214, 1, 0, 0.608418,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654113,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497362,-99) , 
4, 308.061, 0, 0, 0.497868,-99) , 
0, 805.622, 0, 0, 0.499025,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.32576,-99) , 
6, 445.156, 1, 0, 0.498535,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.011193);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657784,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443444,-99) , 
3, 0.333304, 1, 0, 0.607483,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534968,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498172,-99) , 
2, 1.04762, 0, 0, 0.50032,-99) , 
0, 805.622, 0, 0, 0.501441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327933,-99) , 
6, 445.156, 1, 0, 0.500952,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.010708);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 224.327, 1, 1, 0.616586,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529192,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499675,-99) , 
4, 115.611, 0, 0, 0.502716,-99) , 
0, 767.016, 0, 0, 0.504043,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526641,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.252858,-99) , 
4, 63.0914, 0, 0, 0.373847,-99) , 
6, 399.028, 1, 0, 0.503383,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0136541);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 767.016, 0, 1, 0.506112,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523971,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.254886,-99) , 
4, 63.0914, 0, 0, 0.373956,-99) , 
6, 399.028, 1, 0, 0.505444,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.00650001);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.657688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458517,-99) , 
5, 149.214, 1, 0, 0.601316,-99) , 
NN(
0, 
0, 
-1, 308.061, 0, 1, 0.501495,-99) , 
0, 805.622, 0, 0, 0.502535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.329627,-99) , 
6, 445.156, 1, 0, 0.50205,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.00573382);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.64969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441308,-99) , 
3, 0.333304, 1, 0, 0.600693,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.647371,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499395,-99) , 
4, 308.061, 0, 0, 0.49987,-99) , 
0, 805.622, 0, 0, 0.50092,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.331065,-99) , 
6, 445.156, 1, 0, 0.500443,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.00640293);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 767.016, 0, 1, 0.502486,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522156,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.258112,-99) , 
4, 63.0914, 0, 0, 0.375326,-99) , 
6, 399.028, 1, 0, 0.501845,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.00590237);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.654122,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458488,-99) , 
5, 149.214, 1, 0, 0.598727,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.644596,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49923,-99) , 
4, 308.061, 0, 0, 0.499696,-99) , 
0, 805.622, 0, 0, 0.500725,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33213,-99) , 
6, 445.156, 1, 0, 0.500253,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0122714);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 224.327, 1, 1, 0.60791,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459265,-99) , 
1, -1.78077, 0, 0, 0.501094,-99) , 
0, 767.016, 0, 0, 0.502332,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52169,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.259957,-99) , 
4, 63.0914, 0, 0, 0.376344,-99) , 
6, 399.028, 1, 0, 0.501698,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.00797153);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 228.299, 1, 1, 0.595699,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.640487,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497879,-99) , 
4, 308.061, 0, 0, 0.498335,-99) , 
0, 805.622, 0, 0, 0.499344,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.333043,-99) , 
6, 445.156, 1, 0, 0.49888,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0113567);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 228.299, 1, 1, 0.593777,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50248,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470835,-99) , 
6, 187.96, 1, 0, 0.500315,-99) , 
0, 805.622, 0, 0, 0.501283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.334816,-99) , 
6, 445.156, 1, 0, 0.500819,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.00873191);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 228.299, 1, 1, 0.591035,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637168,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497417,-99) , 
4, 308.061, 0, 0, 0.497864,-99) , 
0, 805.622, 0, 0, 0.498828,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.33735,-99) , 
6, 445.156, 1, 0, 0.498379,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0230123);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54643,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.301027,-99) , 
1, 2.00618, 1, 0, 0.529178,-99) , 
NN(
0, 
0, 
-1, 134.565, 1, -1, 0.496595,-99) , 
0, 362.883, 0, 0, 0.501109,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523818,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.264341,-99) , 
4, 63.0914, 0, 0, 0.380163,-99) , 
6, 399.028, 1, 0, 0.500503,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0382186);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 65.9537, 0, 1, 0.556439,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.620806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492523,-99) , 
3, 0.952392, 0, 0, 0.504012,-99) , 
3, -0.571429, 1, 0, 0.505346,-99) , 
NN(
0, 
0, 
-1, 676.571, 1, -1, 0.368395,-99) , 
5, 235.73, 1, 0, 0.504757,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0296);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 805.622, 0, 1, 0.513565,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51731,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.269064,-99) , 
1, 2.38613, 1, 0, 0.431687,-99) , 
1, 2.26154, 1, 0, 0.512755,-99) , 
NN(
0, 
0, 
-1, 676.571, 1, -1, 0.377331,-99) , 
5, 235.73, 1, 0, 0.512175,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0123148);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 767.016, 0, 1, 0.505502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522049,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.270373,-99) , 
4, 63.0914, 0, 0, 0.383108,-99) , 
6, 399.028, 1, 0, 0.504891,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0134853);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428708,-99) , 
3, 0.333304, 1, 0, 0.586258,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472665,-99) , 
6, 187.96, 1, 0, 0.501398,-99) , 
0, 805.622, 0, 0, 0.502272,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.341556,-99) , 
6, 445.156, 1, 0, 0.50183,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.00726396);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 228.299, 1, 1, 0.584621,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.634012,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498054,-99) , 
4, 308.061, 0, 0, 0.498488,-99) , 
0, 805.622, 0, 0, 0.499374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.344595,-99) , 
6, 445.156, 1, 0, 0.498949,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.00366462);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.672023,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498451,-99) , 
6, 228.299, 1, 0, 0.582856,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.632325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49987,-99) , 
4, 308.061, 0, 0, 0.500292,-99) , 
0, 805.622, 0, 0, 0.501141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.346238,-99) , 
6, 445.156, 1, 0, 0.500716,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.00492701);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.671215,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499367,-99) , 
6, 228.299, 1, 0, 0.582907,-99) , 
NN(
0, 
0, 
-1, 308.061, 0, 1, 0.501203,-99) , 
0, 805.622, 0, 0, 0.502043,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.347068,-99) , 
6, 445.156, 1, 0, 0.501617,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.00483431);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.63661,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448105,-99) , 
5, 149.214, 1, 0, 0.582976,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.630325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499555,-99) , 
4, 308.061, 0, 0, 0.499971,-99) , 
0, 805.622, 0, 0, 0.500824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.348185,-99) , 
6, 445.156, 1, 0, 0.500405,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0055055);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430431,-99) , 
3, 0.333304, 1, 0, 0.5825,-99) , 
NN(
0, 
0, 
-1, 308.061, 0, 1, 0.501172,-99) , 
0, 805.622, 0, 0, 0.502007,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349283,-99) , 
6, 445.156, 1, 0, 0.501589,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.00599376);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.629688,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470611,-99) , 
1, 1.75203, 1, 0, 0.593184,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.635263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499287,-99) , 
4, 308.061, 0, 0, 0.499709,-99) , 
0, 767.016, 0, 0, 0.500782,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.27656,-99) , 
4, 63.0914, 0, 0, 0.388882,-99) , 
6, 399.028, 1, 0, 0.500226,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0112891);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 224.327, 1, 1, 0.592432,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502702,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463842,-99) , 
1, -1.78077, 0, 0, 0.501198,-99) , 
0, 767.016, 0, 0, 0.502245,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524315,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.277761,-99) , 
4, 63.0914, 0, 0, 0.38894,-99) , 
6, 399.028, 1, 0, 0.501683,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.00511067);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.66588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497034,-99) , 
6, 228.299, 1, 0, 0.579001,-99) , 
NN(
0, 
0, 
-1, 365.665, 1, -1, 0.498676,-99) , 
0, 805.622, 0, 0, 0.499499,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.349948,-99) , 
6, 445.156, 1, 0, 0.499091,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.00452731);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.631884,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446254,-99) , 
5, 149.214, 1, 0, 0.579072,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500351,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.372392,-99) , 
6, 365.665, 1, 0, 0.499954,-99) , 
0, 805.622, 0, 0, 0.500764,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351111,-99) , 
6, 445.156, 1, 0, 0.500355,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.006968);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62519,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428974,-99) , 
3, 0.333304, 1, 0, 0.578623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.62414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49843,-99) , 
4, 308.061, 0, 0, 0.498829,-99) , 
0, 805.622, 0, 0, 0.499646,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.352144,-99) , 
6, 445.156, 1, 0, 0.499243,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0101717);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.534833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499117,-99) , 
0, 432.703, 0, 0, 0.502223,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504622,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.271207,-99) , 
1, 2.38613, 1, 0, 0.424313,-99) , 
1, 2.26154, 1, 0, 0.501451,-99) , 
NN(
0, 
0, 
-1, 676.571, 1, -1, 0.38296,-99) , 
5, 235.73, 1, 0, 0.500947,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0130074);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 767.016, 0, 1, 0.504409,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.529626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.260843,-99) , 
4, 63.0914, 0, 0, 0.383432,-99) , 
6, 399.028, 1, 0, 0.503818,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.645895,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.415671,-99) , 
2, 0.0952381, 0, 0, 0.501463,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.273222,-99) , 
1, 2.38613, 1, 0, 0.423115,-99) , 
1, 2.26154, 1, 0, 0.503021,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.00431363);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 929.929, 0, 1, 0.500994,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502294,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.275812,-99) , 
1, 2.38613, 1, 0, 0.424629,-99) , 
1, 2.26154, 1, 0, 0.500239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351698,-99) , 
6, 445.156, 1, 0, 0.499835,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0145023);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535775,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497388,-99) , 
0, 432.703, 0, 0, 0.500662,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502919,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.324845,-99) , 
0, 374.617, 1, 0, 0.459194,-99) , 
1, 2.02375, 1, 0, 0.499269,-99) , 
NN(
0, 
0, 
-1, 676.571, 1, -1, 0.381791,-99) , 
5, 235.73, 1, 0, 0.49877,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0212149);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 344.708, 0, 1, 0.506085,-99) , 
NN(
0, 
0, 
-1, -1.57221, 1, -1, 0.468743,-99) , 
1, -1.41844, 0, 0, 0.503145,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.535471,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.375015,-99) , 
4, 19.9103, 0, 0, 0.499293,-99) , 
NN(
0, 
0, 
-1, 61.129, 0, -1, 0.329073,-99) , 
0, 374.617, 1, 0, 0.457482,-99) , 
1, 2.02375, 1, 0, 0.501617,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.00916479);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 224.327, 1, 1, 0.579119,-99) , 
NN(
0, 
0, 
-1, 177.271, 1, -1, 0.496895,-99) , 
0, 767.016, 0, 0, 0.49783,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513375,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.278135,-99) , 
4, 63.0914, 0, 0, 0.384233,-99) , 
6, 399.028, 1, 0, 0.497268,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
